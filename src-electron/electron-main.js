// electron-main.js (DEV-ONLY, non-packaged)
// Runs in Electron's MAIN process (separate from the Vue/Quasar renderer).
// Responsibilities:
//   • Create/manage the BrowserWindow (the small tray/popup UI)
//   • Manage tray icon + shortcuts
//   • Expose a few IPC endpoints used by the renderer:
//       - dict:lookup        → Jisho lookup (HTTP fetch)
//       - ankiconnect:invoke → AnkiConnect bridge (HTTP POST to 127.0.0.1:8765)
//       - morph:tokenize     → Japanese tokenization (kuromoji)
//
// Where logs appear:
//  - Anything with console.log in THIS FILE = Electron main process logs (in your terminal)
//  - Renderer console.log = DevTools console of the BrowserWindow

import { app, BrowserWindow, Tray, Menu, nativeImage, globalShortcut, ipcMain, screen } from 'electron';

import path from 'node:path';
import os from 'node:os';
import { fileURLToPath } from 'node:url';
import http from 'node:http';

import kuromoji from 'kuromoji';
import log from 'electron-log';

const logMain = (...args) => console.log('[main]', ...args);

// Electron can be ESM; emulate __dirname safely for resolving paths.
const currentDir = fileURLToPath(new URL('.', import.meta.url));

// Globals for window/tray references.
let mainWindow = null
let tray = null

// We expect kuromoji dict here:
// `project-root/node_modules/kuromoji/dict`
function resolveKuromojiDicPathDev() {
  const dicPath = path.join(process.cwd(), 'node_modules', 'kuromoji', 'dict');
  logMain('Kuromoji dicPath (dev) ->', dicPath);
  return dicPath;
}

// ------------------------------------------------------------------
// Kuromoji: lazy-build a single tokenizer (dev-only)
// ------------------------------------------------------------------
let tokenizerPromise;

function getTokenizer() {
  if (!tokenizerPromise) {
    const dicPath = resolveKuromojiDicPathDev();
    tokenizerPromise = new Promise((res, rej) => {
      kuromoji.builder({ dicPath }).build((err, t) => err ? rej(err) : res(t));
    });
  }
  return tokenizerPromise;
}
// --- Small helper --------------------------------------------------
const platform = process.platform || os.platform();

// Create the frameless window that behaves like a popover.
async function createWindow () {
  mainWindow = new BrowserWindow({
    width: 500,
    height: 600,
    minWidth: 400,
    minHeight: 300,
    show: false,
    frame: false,
    resizable: true,
    alwaysOnTop: false,
    skipTaskbar: false,
    transparent: false,
    webPreferences: {
      devTools: true,
      // Isolate main & renderer for security.
      contextIsolation: true,
      // Load the preload script generated by Quasar.
      // Quasar/Electron plugin provides these env vars for the preload path.
      preload: path.resolve(
        currentDir,
        path.join(process.env.QUASAR_ELECTRON_PRELOAD_FOLDER,
        'electron-preload' + process.env.QUASAR_ELECTRON_PRELOAD_EXTENSION)
      )
    }
  });
  // In dev, Quasar serves your app on a dev server; in prod, load local file.
  if (process.env.DEV) {
    console.log('[main] loading DEV url:', process.env.APP_URL)
    await mainWindow.loadURL(process.env.APP_URL)
  } else {
    console.log('[main] loading PROD index.html')
    await mainWindow.loadFile('index.html')
  }
  // Cleanup reference when window is closed.
  mainWindow.on('closed', () => {
    console.log('[main] window closed')
    mainWindow = null
  });

  mainWindow.on('blur', () => {
    // if (!mainWindow.webContents.isDevToolsOpened()) mainWindow.hide()
  });

  mainWindow.webContents.on('did-start-loading', () => {
    console.log('[main] renderer did-start-loading')
  });

  mainWindow.webContents.on('did-finish-load', () => {
    console.log('[main] renderer did-finish-load');
    mainWindow.webContents.openDevTools({ mode: 'detach' });
  });
}

function togglePopover () {
  if (!mainWindow) return
  if (mainWindow.isVisible()) {
    mainWindow.hide()
  } else {
    // Position window next to tray icon
    if (tray) {
      const trayBounds = tray.getBounds()
      const windowBounds = mainWindow.getBounds()

      // Get screen work area to ensure window stays on screen
      const { workArea } = screen.getPrimaryDisplay()

      // On macOS, tray icons are in the menu bar at the top of the screen
      // Position window BELOW the tray icon, centered horizontally
      let x = trayBounds.x + (trayBounds.width / 2) - (windowBounds.width / 2)
      let y = trayBounds.y + trayBounds.height + 5 // 5px gap below icon

      // Ensure window doesn't go off right edge
      if (x + windowBounds.width > workArea.x + workArea.width) {
        x = workArea.x + workArea.width - windowBounds.width - 10
      }

      // Ensure window doesn't go off left edge
      if (x < workArea.x) {
        x = workArea.x + 10
      }

      // If window would go below bottom of screen, position above tray instead
      if (y + windowBounds.height > workArea.y + workArea.height) {
        y = trayBounds.y - windowBounds.height - 5
      }

      // Ensure window doesn't go above top of screen (fallback)
      y = Math.max(workArea.y, y)

      mainWindow.setPosition(Math.round(x), Math.round(y))
    }

    mainWindow.show()
    mainWindow.focus()
  }
}

//  --- App Lifecycle -----------------------------------------------
app.whenReady().then(() => {
  console.log('[main] app is ready');
  createWindow();
  console.log('[main] creating tray');

  // Create a tray icon using the custom Anki logo
  const trayPath = path.resolve(process.cwd(), 'src-electron/icons/ankiTrayTemplate.png');
  const trayImage = nativeImage.createFromPath(trayPath).resize({ width: 18, height: 18 });
  trayImage.setTemplateImage(true);
  tray = new Tray(trayImage);
  tray.setToolTip('Ankify');

  // Right-click context menu
  tray.setContextMenu(Menu.buildFromTemplate([
    { label: 'Toggle', click: () => togglePopover() },
    { label: 'Show/Hide', click: () => {
        if (!mainWindow) return
        if (mainWindow.isVisible()) { console.log('[main] hiding'); mainWindow.hide() }
        else { console.log('[main] showing'); mainWindow.show(); mainWindow.focus() }
      }},
    { type: 'separator' },
    { label: 'Quit', role: 'quit' }
  ]))
  tray.on('click', () => {
    console.log('[main] tray clicked')
    togglePopover();
  })
  globalShortcut.register('CommandOrControl+Shift+F', () => togglePopover());

  // open DevTools detached for debugging
  if (process.env.DEBUGGING && mainWindow) mainWindow.webContents.openDevTools({ mode: 'detach' })
});

app.on('window-all-closed', () => {
  console.log('[main] all windows closed');
  if (platform !== 'darwin') {
    console.log('[main] quitting app');
    app.quit();
  }
});

app.on('activate', () => {
  console.log('[main] activate event');
  if (mainWindow === null) {
    createWindow();
  }
});
// --- IPC: window control endpoints -------------------------------------
ipcMain.handle('window:hide', () => {
  if (mainWindow && !mainWindow.isDestroyed()) mainWindow.hide();
});
ipcMain.handle('window:close', () => {
  if (mainWindow && !mainWindow.isDestroyed()) mainWindow.close();
});
ipcMain.handle('window:minimize', () => {
  if (mainWindow && !mainWindow.isDestroyed()) mainWindow.minimize();
});
ipcMain.handle('window:toggle-maximize', () => {
  if (mainWindow && !mainWindow.isDestroyed()) {
    if (mainWindow.isMaximized()) {
      mainWindow.unmaximize();
    } else {
      mainWindow.maximize();
    }
  }
});
ipcMain.handle('window:resize', (_event, { width, height }) => {
  if (mainWindow && !mainWindow.isDestroyed()) {
    // Optional: Limit height to work area
    const { workArea } = screen.getPrimaryDisplay();
    const maxHeight = workArea.height - 20; // buffer
    const newHeight = Math.min(height, maxHeight);

    const currentBounds = mainWindow.getBounds();
    // Only resize if significantly different to avoid loops
    if (Math.abs(currentBounds.height - newHeight) > 2 || Math.abs(currentBounds.width - width) > 2) {
      mainWindow.setSize(width, Math.ceil(newHeight));
    }
  }
});
// --- IPC: Jisho lookup -------------------------------------------------
// Renderer calls: await window.ankify.dictLookup(text)
ipcMain.handle('dict:lookup', async (_event, query) => {
  if (!query || typeof query !== 'string') return { ok: false, error: 'Empty query' };
  try {
    const url = `https://jisho.org/api/v1/search/words?keyword=${encodeURIComponent(query)}`
    const res = await fetch(url)
    if (!res.ok) return { ok: false, error: `HTTP ${res.status}` }
    const json = await res.json()
    return { ok: true, data: json }
  } catch (err) {
    return { ok: false, error: String(err) }
  }
});
// --- IPC: AnkiConnect bridge ------------------------------------------------
// Renderer calls: await window.ankify.invokeAnki(action, params)
// We POST JSON to AnkiConnect on 127.0.0.1:8765 and return result/error.
ipcMain.handle('ankiconnect:invoke', async (_event, { action, params }) => {
  const payload = JSON.stringify({ action, version: 6, params });
  // Node’s http.request() is callback-based and stream-based — not Promise-based.
  // So you can’t just await http.request() directly.
  // That’s why we create a new Promise manually:
  const { status, body } = await new Promise((resolve, reject) => {
    const request = http.request(
      {
        host: '127.0.0.1',
        port: 8765,
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Content-Length': Buffer.byteLength(payload)
        }
      },
      // callback (response) => { … } runs once the remote server (AnkiConnect) sends back an HTTP response.
      // response object emits 'data' events as chunks of text arrive over the network & emits an 'end' event once all chunks are done and the connection is closed.
      (response) => {
        response.setEncoding('utf8');
        let raw = '';
        response.on('data', (chunk) => { raw += chunk; });
        response.on('end', () => resolve({ status: response.statusCode ?? 0, body: raw }));
      }
    );
    request.setTimeout(5000, () => {
      request.destroy(new Error('Request timed out'));
    });
    request.on('error', reject);
    request.write(payload);
    request.end();
  });
  if (status !== 200) {
    throw new Error(`AnkiConnect HTTP ${status}: ${body}`);
  }
  let parsed;
  try {
    parsed = JSON.parse(body || '{}');
  } catch (e) {
    throw new Error(`Invalid JSON from AnkiConnect: ${String(e)}`);
  }
  if (parsed.error) throw new Error(parsed.error);
  return parsed.result;
});

ipcMain.on('ankify:log', (_evt, args) => {
  console.log('[RENDERER]', ...args);
  log.info('[RENDERER]', ...args);
});
// --- IPC: kuromoji tokenization ------------------------------------------
// Renderer calls: await window.ankify.tokenize(text)
// We just build the tokenizer once, then tokenize each string.
ipcMain.handle('morph:tokenize', async (_e, text) => {
  const t = await getTokenizer();
  return t.tokenize(text || '');
});
