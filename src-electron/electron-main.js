// electron-main.js
// This runs in Electron's "main process" (not in Vue/Quasar frontend) - manages windows, tray, and system-level integration
import { app, BrowserWindow, Tray, Menu, nativeImage, globalShortcut, screen, ipcMain } from 'electron'
import path from 'node:path';
import os from 'node:os';
import { fileURLToPath } from 'node:url';

import log from 'electron-log';

// fallback in case process.platform is undefined
const platform = process.platform || os.platform()

// ESM-safe __dirname
const currentDir = fileURLToPath(new URL('.', import.meta.url))

let mainWindow = null
let tray = null

async function createWindow () {
  console.log('[main] createWindow called')

  mainWindow = new BrowserWindow({
    width: 400,
    height: 270,
    show: false,               
    frame: false, // no titlebar 
    resizable: false,
    alwaysOnTop: true,
    skipTaskbar: true,
    transparent: true,         
    webPreferences: {
      devTools: true,
      // Isolate main & renderer for security
      contextIsolation: true,
      // Load the preload script generated by Quasar
      preload: path.resolve(
        currentDir,
        path.join(process.env.QUASAR_ELECTRON_PRELOAD_FOLDER, 'electron-preload' + process.env.QUASAR_ELECTRON_PRELOAD_EXTENSION)
      )
    }
      
  }
);

  if (process.env.DEV) {
    console.log('[main] loading DEV url:', process.env.APP_URL)
    await mainWindow.loadURL(process.env.APP_URL)
  } else {
    console.log('[main] loading PROD index.html')
    await mainWindow.loadFile('index.html')
  }

  mainWindow.on('closed', () => {
    console.log('[main] window closed')
    mainWindow = null
  })

  mainWindow.on('blur', () => {
    if (!mainWindow.webContents.isDevToolsOpened()) mainWindow.hide()
  })
  
  mainWindow.webContents.on('did-start-loading', () => {
    console.log('[main] renderer did-start-loading')
  })

  mainWindow.webContents.on('did-finish-load', () => {
    console.log('[main] renderer did-finish-load')
  })
}

function positionNearTrayAndShow () {
  if (!tray || !mainWindow) return

  const icon = tray.getBounds()
  const display = screen.getDisplayNearestPoint({ x: icon.x, y: icon.y }).bounds
  const [winW, winH] = mainWindow.getSize()
  const PADDING = 8

  // Ideal centered X under/over the tray icon
  const idealX = icon.x + icon.width / 2 - winW / 2

  // Clamp X so we stay fully on-screen
  const leftEdge  = display.x
  const rightEdge = display.x + display.width - winW
  const x = Math.round(Math.max(leftEdge, Math.min(idealX, rightEdge)))

  // Y depends on platform (menu bar vs taskbar)
  const y = platform === 'darwin'
    ? Math.round(icon.y + icon.height + PADDING)   // below menu bar
    : Math.round(icon.y - winH - PADDING)          // above taskbar

  mainWindow.setPosition(x, y, false)
  mainWindow.show()
  mainWindow.focus()
}

function togglePopover () {
  if (!mainWindow) return
  if (mainWindow.isVisible()) mainWindow.hide()
  else positionNearTrayAndShow()
}

// ==== APP EVENTS ====
app.whenReady().then(() => {
  console.log('[main] app is ready')
  createWindow()
  console.log('[main] creating tray')
  const trayPath = path.resolve(process.cwd(), 'src-electron/icons/trayTemplate.png')
  const trayImage = nativeImage.createFromPath(trayPath).resize({ width: 15, height: 15 })
  trayImage.setTemplateImage(true)
  tray = new Tray(trayImage); 
  tray.setTitle('âš¡');                
  tray.setToolTip('Ankify');

  // Right-click context menu
  tray.setContextMenu(Menu.buildFromTemplate([
    { label: 'Toggle', click: () => togglePopover() },
    { label: 'Show/Hide', click: () => {
        if (!mainWindow) return
        if (mainWindow.isVisible()) { console.log('[main] hiding'); mainWindow.hide() }
        else { console.log('[main] showing'); mainWindow.show(); mainWindow.focus() }
      }},
    { type: 'separator' },
    { label: 'Quit', role: 'quit' }
  ]))
  tray.on('click', () => {
    console.log('[main] tray clicked')
    if (!mainWindow) return
    if (mainWindow.isVisible()) {
       mainWindow.hide() 
      } else { 
        positionNearTrayAndShow() 
      }
  })

  
  globalShortcut.register('CommandOrControl+Shift+F', () => togglePopover())

  // open DevTools detached for debugging
  if (process.env.DEBUGGING && mainWindow) mainWindow.webContents.openDevTools({ mode: 'detach' })
})

app.on('window-all-closed', () => {
  console.log('[main] all windows closed')
  if (platform !== 'darwin') {
    console.log('[main] quitting app')
    app.quit()
  }
})

app.on('activate', () => {
  console.log('[main] activate event')
  if (mainWindow === null) {
    createWindow()
  }
})

ipcMain.handle('window:hide', () => {
  if (mainWindow && !mainWindow.isDestroyed()) mainWindow.hide()
})

ipcMain.handle('window:close', () => {
  if (mainWindow && !mainWindow.isDestroyed()) mainWindow.close() 
})

ipcMain.handle('dict:lookup', async (_event, query) => {
  if (!query || typeof query !== 'string') return { ok: false, error: 'Empty query' }
  try {
    const url = `https://jisho.org/api/v1/search/words?keyword=${encodeURIComponent(query)}`
    const res = await fetch(url) 
    if (!res.ok) return { ok: false, error: `HTTP ${res.status}` }
    const json = await res.json()
    return { ok: true, data: json }
  } catch (err) {
    return { ok: false, error: String(err) }
  }
})

ipcMain.on('ankify:log', (_evt, args) => {
  // Mirror to terminal and file
  console.log('[RENDERER]', ...args);
  log.info('[RENDERER]', ...args);
});